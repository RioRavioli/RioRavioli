[["version", 4], ["markdown", "\n[Traits](http://en.wikipedia.org/wiki/Trait_%28computer_science%29) are a simple\nmechanism for structuring object-oriented programs. They represent reusable and\ncomposable building blocks of functionality that factor out the common\nattributes and behavior of objects.\n\nThey are a more robust alternative to\n[mixins](http://en.wikipedia.org/wiki/Mixins) and\n[multiple inheritance](http://en.wikipedia.org/wiki/Multiple_inheritance),\nbecause name clashes must be explicitly resolved and composition is commutative\nand associative (i.e. the order of traits in a composition is irrelevant).\n\nUse traits to share functionality between similar objects without duplicating\ncode or creating complex inheritance chains.\n\n## Trait Creation ##\n\nTo create a trait, call the `Trait` constructor function exported by this\nmodule, passing it a JavaScript object that specifies the properties of the\ntrait.\n\n    let Trait = require('light-traits').Trait;\n    let t = Trait({\n      foo: \"foo\",\n      bar: function bar() {\n        return \"Hi!\"\n      },\n      baz: Trait.required\n    });\n\nTraits can both provide and require properties. A *provided* property is a\nproperty for which the trait itself provides a value. A *required* property is a\nproperty that the trait needs in order to function correctly but for which\nit doesn't provide a value.\n\nRequired properties must be provided by another trait or by an object with a\ntrait. Creation of an object with a trait will fail if required properties are\nnot provided. Specify a required property by setting the value of the property\nto `Trait.required`.\n\n## Object Creation ##\n\nCreate objects with a single trait by calling the trait's `create` method. The\nmethod takes a single argument, the object to serve as the new object's\nprototype. If no prototype is specified, the new object's prototype will be\n`Object.prototype`.\n\n    let t = Trait({\n      foo: 'foo',\n      bar: 2\n    });\n    let foo1 = t.create();\n    let foo2 = t.create({ name: 'Super' });\n\n## Trait Composition ##\n\nTraits are designed to be composed with other traits to create objects with the\nproperties of multiple traits. To compose an object with multiple traits, you\nfirst create a composite trait and then use it to create the object. A composite\ntrait is a trait that contains all of the properties of the traits from which it\nis composed. In the following example, MagnitudeTrait is a composite trait.\n\n    let EqualityTrait = Trait({\n      equal: Trait.required,\n      notEqual: function notEqual(x) {\n        return !this.equal(x)\n      }\n    });\n    \n    let ComparisonTrait = Trait({\n      less: Trait.required,\n      notEqual: Trait.required,\n      greater: function greater(x) {\n        return !this.less(x) && this.notEqual(x)\n      }\n    });\n    \n    let MagnitudeTrait = Trait.compose(EqualityTrait, ComparisonTrait);\n\n<?xml version=\"1.0\"?>\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xl=\"http://www.w3.org/1999/xlink\" version=\"1.1\" viewBox=\"-11 121 490 190\" width=\"490px\" height=\"190px\">\n  <defs>\n    <marker orient=\"auto\" overflow=\"visible\" markerUnits=\"strokeWidth\" id=\"SharpArrow_Marker\" viewBox=\"-4 -4 10 8\" markerWidth=\"10\" markerHeight=\"8\" color=\"black\">\n      <g>\n        <path d=\"M 5 0 L -3 -3 L 0 0 L 0 0 L -3 3 Z\" fill=\"currentColor\" stroke=\"currentColor\" stroke-width=\"1px\"/>\n      </g>\n    </marker>\n  </defs>\n  <g stroke=\"none\" stroke-opacity=\"1\" stroke-dasharray=\"none\" fill=\"none\" fill-opacity=\"1\">\n    <g>\n      <rect x=\"9\" y=\"165.33334\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"165.33334\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 165.33334)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" x=\"0\" y=\"11\" textLength=\"47.373047\">notEqual</tspan>\n      </text>\n      <rect x=\"9\" y=\"151.33334\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"151.33334\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 151.33334)\" fill=\"red\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" fill=\"red\" x=\"0\" y=\"11\" textLength=\"29.361328\">equal</tspan>\n      </text>\n      <rect x=\"9\" y=\"137.33334\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"137.33334\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 137.33334)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"bold\" x=\"38.49707\" y=\"11\" textLength=\"54.00586\">EqualityTrait</tspan>\n      </text>\n      <rect x=\"9\" y=\"273\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"273\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 273)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" x=\"0\" y=\"11\" textLength=\"38.021484\">greater</tspan>\n      </text>\n      <rect x=\"9\" y=\"259\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"259\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 259)\" fill=\"red\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" fill=\"red\" x=\"0\" y=\"11\" textLength=\"47.373047\">notEqual</tspan>\n      </text>\n      <rect x=\"9\" y=\"245\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"245\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 245)\" fill=\"red\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" fill=\"red\" x=\"0\" y=\"11\" textLength=\"21.339844\">less</tspan>\n      </text>\n      <rect x=\"9\" y=\"231\" width=\"141\" height=\"14\"/>\n      <rect x=\"9\" y=\"231\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(14 231)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"bold\" x=\".15332031\" y=\"11\" textLength=\"112.67578\">ComparisonTrait</tspan>\n      </text>\n      <rect x=\"317.75\" y=\"235.5\" width=\"141\" height=\"14\"/>\n      <rect x=\"317.75\" y=\"235.5\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(322.75 235.5)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" x=\"0\" y=\"11\" textLength=\"38.021484\">greater</tspan>\n      </text>\n      <rect x=\"317.75\" y=\"221.5\" width=\"141\" height=\"14\"/> \n      <rect x=\"317.75\" y=\"221.5\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(322.75 221.5)\" fill=\"red\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" fill=\"red\" x=\"0\" y=\"11\" textLength=\"21.339844\">less</tspan>\n      </text>\n      <rect x=\"317.75\" y=\"207.5\" width=\"141\" height=\"14\"/>\n      <rect x=\"317.75\" y=\"207.5\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(322.75 207.5)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" x=\"0\" y=\"11\" textLength=\"47.373047\">notEqual</tspan>\n      </text>\n      <rect x=\"317.75\" y=\"193.5\" width=\"141\" height=\"14\"/>\n      <rect x=\"317.75\" y=\"193.5\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(322.75 193.5)\" fill=\"red\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"500\" fill=\"red\" x=\"0\" y=\"11\" textLength=\"29.361328\">equal</tspan>\n      </text>\n      <rect x=\"317.75\" y=\"179.5\" width=\"141\" height=\"14\"/>\n      <rect x=\"317.75\" y=\"179.5\" width=\"141\" height=\"14\" stroke=\"black\" stroke-width=\"1px\"/>\n      <text transform=\"translate(322.75 179.5)\" fill=\"black\">\n        <tspan font-family=\"Helvetica\" font-size=\"12\" font-weight=\"bold\" x=\"31.83789\" y=\"11\" textLength=\"67.32422\">MagnitudeTrait</tspan>\n      </text>\n      <path d=\"M 150 248.83887 L 158.89999 248.83887 L 235.9 248.83887 L 235.9 224.66113 L 308.85 224.66113 L 310.85 224.66113\" marker-end=\"url(#SharpArrow_Marker)\" stroke=\"black\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-width=\"1px\"/>\n      <path d=\"M 150 171.15845 L 158.89999 171.15845 L 233.9 171.15845 L 233.9 201.6749 L 308.85 201.6749 L 310.85 201.6749\" marker-end=\"url(#SharpArrow_Marker)\" stroke=\"black\" stroke-linecap=\"butt\" stroke-linejoin=\"miter\" stroke-width=\"1px\"/>\n    </g>\n  </g>\n</svg>\n\n## Trait Resolution ##\n\nComposite traits have conflicts when two of the traits in the composition\nprovide properties with the same name but different values (when compared using\nthe `===` strict equality operator). In the following example, `TC` has a\nconflict because `T1` and `T2` both define a `foo` property:\n\n    let T1 = Trait({\n      foo: function () {\n        // do something\n      },\n      bar: 'bar',\n      t1: 1\n    });\n    \n    let T2 = Trait({\n      foo: function() {\n        // do something else\n      },\n      bar: 'bar',\n      t2: 2\n    });\n    \n    let TC = Trait.compose(T1, T2);\n\nAttempting to create an object from a composite trait with conflicts throws a\n`remaining conflicting property` exception. To create objects from such traits,\nyou must resolve the conflict.\n\nYou do so by excluding or renaming the conflicting property of one of the\ntraits. Excluding a property removes it from the composition, so the composition\nonly acquires the property from the other trait. Renaming a property gives it a\nnew, non-conflicting name at which it can be accessed.\n\nIn both cases, you call the `resolve` method on the trait whose property you\nwant to exclude or rename, passing it an object. Each key in the object is the\nname of a conflicting property; each value is either `null` to exclude the\nproperty or a string representing the new name of the property.\n\nFor example, the conflict in the previous example could be resolved by excluding\nthe `foo` property of the second trait.\n\n    let TC = Trait(T1, T2.resolve({ foo: null }));\n\nIt could also be resolved by renaming the `foo` property of the first trait to\n`foo2`:\n\n    let TC = Trait(T1.resolve({ foo: \"foo2\" }), T2);\n\nWhen you resolve a conflict, the same-named property of the other trait (the one\nthat wasn't excluded or renamed) remains available in the composition under its\noriginal name.\n\n## Constructor Functions ##\n\nWhen your code is going to create more than one object with traits, you may want\nto define a constructor function to create them. To do so, create a composite\ntrait representing the traits the created objects should have, then define a\nconstructor function that creates objects with that trait and whose prototype is\nthe prototype of the constructor:\n\n    let PointTrait = Trait.compose(T1, T2, T3);\n    function Point(options) {\n      let point = PointTrait.create(Point.prototype);\n      return point;\n    }\n\n## Property Descriptor Maps ##\n\nTraits are designed to work with the new object manipulation APIs defined in\n[ECMAScript-262, Edition\n5](http://www.ecma-international.org/publications/standards/Ecma-262.htm) (ES5).\nTraits are also property descriptor maps that inherit from `Trait.prototype` to\nexpose methods for creating objects and resolving conflicts.\n\nThe following trait definition:\n\n    let FooTrait = Trait({\n      foo: \"foo\",\n      bar: function bar() {\n        return \"Hi!\"\n      },\n      baz: Trait.required\n    });\n\nCreates the following property descriptor map:\n\n    {\n      foo: {\n        value: 'foo',\n        enumerable: true,\n        configurable: true,\n        writable: true\n      },\n    \n      bar: {\n        value: function b() {\n          return 'bar'\n        },\n        enumerable: true,\n        configurable: true,\n        writable: true\n      },\n    \n      baz: {\n        get baz() { throw new Error('Missing required property: `baz`') }\n        set baz() { throw new Error('Missing required property: `baz`') }\n      },\n    \n      __proto__: Trait.prototype\n    }\n\nSince Traits are also property descriptor maps, they can be used with built-in\n`Object.*` methods that accept such maps:\n\n    Object.create(proto, FooTrait);\n    Object.defineProperties(myObject, FooTrait);\n\nNote that conflicting and required properties won't cause exceptions to be\nthrown when traits are used with the `Object.*` methods, since those methods are\nnot aware of those constraints. However, such exceptions will be thrown when the\nproperty with the conflict or the required but missing property is accessed.\n\nProperty descriptor maps can also be used in compositions. This may be useful\nfor defining non-enumerable properties, for example:\n\n    let TC = Trait.compose(\n      Trait({ foo: 'foo' }),\n      { bar: { value: 'bar', enumerable: false } }\n    );\n\n_When using property descriptor maps in this way, make sure the map is not the\nonly argument to `Trait.compose`, since in that case it will be interpreted as\nan object literal with properties to be defined._\n\n"]]