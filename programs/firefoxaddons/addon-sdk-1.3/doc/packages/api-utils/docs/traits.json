[["version", 4], ["markdown", "<!-- contributed by Irakli Gozalishvil [gozala@mozilla.com]  -->\n\nThe `traits` module provides base building blocks for secure object\ncomposition. It exports base trait / constructor function that\nconstructs an instance of `Trait`.\n\n[Traits](http://en.wikipedia.org/wiki/Trait_%28computer_science%29) are a\nsimple composition mechanism for structuring object-oriented programs. Traits\nare similar to\n[interfaces](http://en.wikipedia.org/wiki/Interface_%28object-oriented_programming%29),\nexcept that they often define only a part of an object's data and behavior and\nare intended to be used in conjunction with other traits to completely define\nthe object.\n\nTraits are also considered to be a more robust alternative to\n[mixins](http://en.wikipedia.org/wiki/Mixins) because, name conflicts have to\nbe resolved explicitly by composer & because trait composition is\norder-independent (hence more declarative).\n\n\nThere are some other implementations of traits in JavaScript & some ideas /\nAPIs are borrowed from them:\n\n- [traitsjs](http://www.traitsjs.org/)\n- [joose](http://code.google.com/p/joose-js/)\n\nObject-capability security model\n--------------------------------\n\nImplementation uses an\n[object-capability security model](http://en.wikipedia.org/wiki/Object-capability_model)\nto allow protection of private APIs. At the same private APIs can be shared\nbetween among trait composition parties. To put it simply: All the properties\nwhose names start with `\"_\"` are considered to be **private**, and are\nunaccessible from anywhere except other **public** methods / accessors of the\ninstance that had been defined during composition.\n\n"], ["api-json", {"line_number": 38, "name": "Trait", "constructors": [{"line_number": 40, "signature": "Trait()", "type": "constructor", "name": "Trait", "description": "Creates an instance of Trait and returns it if it has no `constructor` method\ndefined. If instance has `constructor` method, then it is called with all the\narguments passed to this function and returned value is returned instead,\nunless it's `undefined`. In that case instance is returned.\n\n`Trait` function represents a base trait. As with any other trait it represents\na constructor function for creating instances of its own & a placeholder\nfor a trait compositions functions."}], "methods": [{"line_number": 52, "name": "compose", "returns": {"datatype": "Function", "line_number": 110, "description": "New trait containing the combined properties of all the traits."}, "params": [{"datatype": "Object|Function", "line_number": 103, "required": true, "name": "trait1", "description": "Trait or property map to compose new trait from."}, {"datatype": "Object|Function", "line_number": 105, "required": true, "name": "trait2", "description": "Trait or property map to compose new trait from."}, {"datatype": "Object|Function", "line_number": 107, "required": true, "name": "...", "description": "Traits or property maps to compose new trait from.\n"}], "signature": "compose(trait1, trait2, ...)", "type": "method", "description": "Composes new trait out of itself and traits / property maps passed as an\narguments. If two or more traits / property maps have properties with the same\nname, the new trait will contain a \"conflict\" property for that name (see\nexamples in Examples section to find out more about \"conflict\" properties).\nThis is a commutative and associative operation, and the order of its\narguments is not significant.\n\n**Examples:**\n\nLet's say we want to define a reusable piece of code for a lists of elements.\n\n    var { Trait } = require('traits');\n    var List = Trait.compose({\n      // private API:\n      _list: null,\n      // public API\n      constructor: function List() {\n        this._list = [];\n      },\n      get length() this._list.length,\n      add: function add(item) this._list.push(item),\n      remove: function remove(item) {\n        let list = this._list;\n        let index = list.indexOf(item);\n        if (0 <= index) list.splice(index, 1);\n      }\n    });\n\nInstances of `List` can be created by calling `List` function with or without\n`new` keyword.\n\n    let l1 = List();\n    l1 instanceof List;      // true\n    let l2 = new List();\n    l2 instanceof List;      // true\n\nAs you can see `add` and `remove` functions are capable of accessing private\n`_list` property, but thats about it, there's nothing else that will be able\nto access this property:\n\n    '_list' in l1;              // false\n    '_list' in l2;              // false\n    '_list' in List.protoype;   // false\n    l1.has = function(name) name in this\n    l1.has('_list');            // false\n    l1.length;                  // 0\n    l1.add('test')\n    l1.length                   // 1\n"}, {"line_number": 142, "name": "resolve", "returns": {"datatype": "Function", "line_number": 181, "description": "New resolved trait."}, "params": [{"datatype": "Object", "line_number": 180, "required": true, "name": "resolutions", "description": ""}], "signature": "resolve(resolutions)", "type": "method", "description": "Composes a new trait that has all the same properties\nas the trait on which it is called, except that each property listed\nin the `resolutions` argument will be renamed from the name\nof the  property in the `resolutions` argument to its value.\nAnd if its value is `null`, the property will become required.\n\n**Example:**\n\n    var Range = List.resolve({\n      constructor: null,\n      add: '_add',\n    }).compose({\n      min: null,\n      max: null,\n      get list() this._list.slice(0),\n      constructor: function Range(min, max) {\n        this.min = min;\n        this.max = max;\n        this._list = [];\n      },\n      add: function(item) {\n        if (item <= this.max && item >= this.min)\n          this._add(item)\n      }\n    });\n\n\n    let r = Range(0, 10);\n    r.min;                      // 0\n    r.max;                      // 10\n    r.length;                   // 0;\n    r.add(5);\n    r.length;                   // 1\n    r.add(12);\n    r.length;                   // 1 (12 was not in a range)\n"}, {"line_number": 185, "name": "override", "returns": {"datatype": "Function", "line_number": 214, "description": "New trait containing the combined properties of all the traits."}, "params": [{"datatype": "Object|Function", "line_number": 207, "required": true, "name": "trait1", "description": "Trait or property map to compose new trait from."}, {"datatype": "Object|Function", "line_number": 209, "required": true, "name": "trait2", "description": "Trait or property map to compose new trait from."}, {"datatype": "Object|Function", "line_number": 211, "required": true, "name": "...", "description": "Traits or property maps to compose new trait from.\n"}], "signature": "override(trait1, trait2, ...)", "type": "method", "description": "Composes a new trait with all of the combined properties of `this` and the\nargument traits. In contrast to `compose`, `override` immediately resolves\nall conflicts resulting from this composition by overriding the properties of\nlater traits. Trait priority is from left to right. I.e. the properties of\nthe leftmost trait are never overridden.\n\n**Example:**\n\n    // will compose trait with conflict property 'constructor'\n    var ConstructableList = List.compose({\n      constructor: function List() this._list = Array.slice(arguments)\n    });\n    // throws error with message 'Remaining conflicting property: constructor'\n    ConstructableList(1, 2, 3);\n\n    var ConstructableList = List.override({\n      constructor: function List() this._list = Array.slice(arguments)\n    });\n    ConstructableList(1, 2, 3).length       // 3\n"}, {"line_number": 224, "signature": "toString()", "type": "method", "name": "toString", "description": "Textual representation of an object. All the traits will return:\n`'[object Trait]'` string, unless they have `constructor` property, in that\ncase string `'Trait'` is replaced with the name of `constructor` property.\n\n**Example:**\n\n    var MyTrait = Trait.compose({\n      constructor: function MyTrait() {\n        // do your initialization here\n      }\n    });\n    MyTrait().toString();     // [object MyTrait]\n"}], "type": "class", "properties": [{"datatype": "Object", "line_number": 114, "type": "property", "name": "required", "description": "Singleton, used during trait composition to define \"required\" properties.\n\n**Example:**\n\n    var Enumerable = Trait.compose({\n      list: Trait.required,\n      forEach: function forEach(consumer) {\n        return this.list.forEach(consumer);\n      }\n    });\n\n    let c1 = Enumerable();      // Error: Missing required property: list\n\n    var EnumerableList = List.compose({\n      get list() this._list.slice(0)\n    }, Enumerable);\n\n    let c2 = EnumerableList();\n    c2.add('test')\n    c2.length                   // 1\n    c2.list[0]                  // 'test'\n    c2.forEach(console.log)     // > info: 'test 0 test'\n"}, {"datatype": "Object", "line_number": 218, "type": "property", "name": "_public", "description": "Internal property of instance representing public API that is exposed to the\nconsumers of an instance."}], "description": "\n\n\n\n\n\n"}], ["markdown", "\n"]]