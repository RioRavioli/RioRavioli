[["version", 4], ["markdown", "\n## Property Encapsulation ##\n\nIn JavaScript it is not possible to create properties that have limited or\ncontrolled accessibility. It is possible to create non-enumerable and\nnon-writable properties, but still they can be discovered and accessed.\nUsually so called \"closure capturing\" is used to encapsulate such properties\nin lexical scope:\n\n    function Foo() {\n      var _secret = 'secret';\n      this.hello = function hello() {\n        return 'Hello ' + _secret;\n      }\n    }\n\nThis provides desired result, but has side effect of degrading code readability,\nespecially with object-oriented programs. Another disadvantage with this pattern\nis that there is no immediate solution for inheriting access to the privates\n(illustrated by the following example):\n\n    function Derived() {\n      this.hello = function hello() {\n        return _secret;\n      }\n      this.bye = function bye() {\n        return _secret;\n      }\n    }\n    Derived.prototype = Object.create(Foo.prototype);\n\n## Facade Objects ##\n\nAlternatively constructor can returned facade objects - proxies to the\ninstance's public properties:\n\n    function Foo() {\n      var foo = Object.create(Foo.prototype);\n      return {\n        bar: foo.hello.bind(foo);\n      }\n    }\n    Foo.prototype._secret = 'secret';\n    Foo.prototype.hello = function hello() {\n      return 'Hello ' + this._secret;\n    }\n\n    function Derived() {\n      var derived = Object.create(Derived.prototype);\n      return {\n        bar: derived.hello.bind(derived);\n        bye: derived.bye.bind(derived);\n      }\n    }\n    Derived.prototype = Object.create(Foo.prototype);\n    Derived.prototype.bye = function bye() {\n      return 'Bye ' + this._secret;\n    };\n\nWhile this solution solves given issue and provides proper encapsulation for\nboth own and inherited private properties, it does not addresses following:\n\n - Privates defined on the `prototype` can be compromised, since they are\n   accessible through the constructor (`Foo.prototype._secret`).\n - Behavior of `instanceof` is broken, since `new Derived() instanceof Derived`\n   is going to evaluate to `false`.\n\n## Tamper Proofing with Property Descriptor Maps ##\n\nIn ES5 new property descriptor maps were introduced, which can be used as a\nbuilding blocks for defining reusable peace of functionality. To some degree\nthey are similar to a `prototype` objects, and can be used so to define pieces\nof functionality that is considered to be private (In contrast to `prototype`\nthey are not exposed by default).\n\n    function Foo() {\n      var foo = Object.create(Foo.prototype, FooDescriptor);\n      var facade = Object.create(Foo.prototype);\n      facade.hello = foo.hello.bind(foo);\n      return facade;\n    }\n    Foo.prototype.hello = function hello() {\n      return 'Hello ' + this._secret;\n    }\n    var FooDescriptor = {\n      _secret: { value: 'secret' };\n    }\n\n    function Derived() {\n      var derived = Object.create(Derived.prototype, DerivedDescriptor);\n      var facade = Object.create(Derived.prototype);\n      facade.hello = derived.hello.bind(derived);\n      facade.bye = derived.bye.bind(derived);\n      return facade;\n    }\n    Derived.prototype = Object.create(Foo.prototype);\n    Derived.prototype.bye = function bye() {\n      return 'Bye ' + this._secret;\n    };\n    DerivedDescriptor = {};\n\n    Object.keys(FooDescriptor).forEach(function(key) {\n      DerivedDescriptor[key] = FooDescriptor[key];\n    });\n\n## Cortex Objects ##\n\nLast approach solves all of the concerns, but adds complexity, verbosity\nand decreases code readability. Combination of `Cortex`'s and `Trait`'s\nwill gracefully solve all these issues and keep code clean:\n\n    var Cortex = require('cortex').Cortex;\n    var Trait = require('light-traits').Trait;\n\n    var FooTrait = Trait({\n      _secret: 'secret',\n      hello: function hello() {\n        return 'Hello ' + this._secret;\n      }\n    });\n    function Foo() {\n      return Cortex(FooTrait.create(Foo.prototype));\n    }\n\n    var DerivedTrait = Trait.compose(FooTrait, Trait({\n      bye: function bye() {\n        return 'Bye ' + this._secret;\n      }\n    }));\n    function Derived() {\n      var derived = DerivedTrait.create(Derived.prototype);\n      return Cortex(derived);\n    }\n\nFunction `Cortex` takes any object and returns a proxy for its public\nproperties. By default properties are considered to be public if they don't\nstart with `\"_\"`, but default behavior can be overridden if needed, by passing\narray of public property names as a second argument.\n\n## Gotchas ##\n\n`Cortex` is just a utility function to create a proxy object, and it does not\nsolve the `prototype`-related issues highlighted earlier, but since traits make\nuse of property descriptor maps instead of `prototype`s, there aren't any\nissues with using `Cortex` to wrap objects created from traits.\n\nIf you want to use `Cortex` with an object that uses a `prototype` chain,\nhowever, you should either make sure you don't have any private properties\nin the prototype chain or pass the optional third `prototype` argument.\n\nIn the latter case, the returned proxy will inherit from the given prototype,\nand the `prototype` chain of the wrapped object will be inaccessible.\nHowever, note that the behavior of the `instanceof` operator will vary,\nas `proxy instanceof Constructor` will return false even if the Constructor\nfunction's prototype is in the wrapped object's prototype chain.\n\n"]]