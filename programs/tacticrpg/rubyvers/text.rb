class TextBox
	A = [Rubygame::Surface.load("visuals/text/letters/CA.png"), 10]
	B = [Rubygame::Surface.load("visuals/text/letters/CB.png"), 12]
	C = [Rubygame::Surface.load("visuals/text/letters/CC.png"), 12]
	D = [Rubygame::Surface.load("visuals/text/letters/CD.png"), 12]
	E = [Rubygame::Surface.load("visuals/text/letters/CE.png"), 12]
	F = [Rubygame::Surface.load("visuals/text/letters/CF.png"), 12]
	G = [Rubygame::Surface.load("visuals/text/letters/CG.png"), 12]
	H = [Rubygame::Surface.load("visuals/text/letters/CH.png"), 14]
	I = [Rubygame::Surface.load("visuals/text/letters/CI.png"), 8]
	J = [Rubygame::Surface.load("visuals/text/letters/CJ.png"), 12]
	K = [Rubygame::Surface.load("visuals/text/letters/CK.png"), 12]
	L = [Rubygame::Surface.load("visuals/text/letters/CL.png"), 10]
	M = [Rubygame::Surface.load("visuals/text/letters/CM.png"), 12]
	N = [Rubygame::Surface.load("visuals/text/letters/CN.png"), 12]
	O = [Rubygame::Surface.load("visuals/text/letters/CO.png"), 12]
	P = [Rubygame::Surface.load("visuals/text/letters/CP.png"), 12]
	Q = [Rubygame::Surface.load("visuals/text/letters/CQ.png"), 14]
	R = [Rubygame::Surface.load("visuals/text/letters/CR.png"), 12]
	S = [Rubygame::Surface.load("visuals/text/letters/CS.png"), 12]
	T = [Rubygame::Surface.load("visuals/text/letters/CT.png"), 12]
	U = [Rubygame::Surface.load("visuals/text/letters/CU.png"), 12]
	V = [Rubygame::Surface.load("visuals/text/letters/CV.png"), 12]
	W = [Rubygame::Surface.load("visuals/text/letters/CW.png"), 16]
	X = [Rubygame::Surface.load("visuals/text/letters/CX.png"), 12]
	Y = [Rubygame::Surface.load("visuals/text/letters/CY.png"), 12]
	Z = [Rubygame::Surface.load("visuals/text/letters/CZ.png"), 12]

	LA = [Rubygame::Surface.load("visuals/text/letters/la.png"), 12]
	LB = [Rubygame::Surface.load("visuals/text/letters/lb.png"), 10]
	LC = [Rubygame::Surface.load("visuals/text/letters/lc.png"), 10]
	LD = [Rubygame::Surface.load("visuals/text/letters/ld.png"), 10]
	LE = [Rubygame::Surface.load("visuals/text/letters/le.png"), 10]
	LF = [Rubygame::Surface.load("visuals/text/letters/lf.png"), 8]
	LG = [Rubygame::Surface.load("visuals/text/letters/lg.png"), 10]
	LH = [Rubygame::Surface.load("visuals/text/letters/lh.png"), 10]
	LI = [Rubygame::Surface.load("visuals/text/letters/li.png"), 4]
	LJ = [Rubygame::Surface.load("visuals/text/letters/lj.png"), 6]
	LK = [Rubygame::Surface.load("visuals/text/letters/lk.png"), 8]
	LL = [Rubygame::Surface.load("visuals/text/letters/ll.png"), 4]
	LM = [Rubygame::Surface.load("visuals/text/letters/lm.png"), 12]
	LN = [Rubygame::Surface.load("visuals/text/letters/ln.png"), 10]
	LO = [Rubygame::Surface.load("visuals/text/letters/lo.png"), 10]
	LP = [Rubygame::Surface.load("visuals/text/letters/lp.png"), 10]
	LQ = [Rubygame::Surface.load("visuals/text/letters/lq.png"), 10]
	LR = [Rubygame::Surface.load("visuals/text/letters/lr.png"), 10]
	LS = [Rubygame::Surface.load("visuals/text/letters/ls.png"), 10]
	LT = [Rubygame::Surface.load("visuals/text/letters/lt.png"), 8]
	LU = [Rubygame::Surface.load("visuals/text/letters/lu.png"), 10]
	LV = [Rubygame::Surface.load("visuals/text/letters/lv.png"), 10]
	LW = [Rubygame::Surface.load("visuals/text/letters/lw.png"), 12]
	LX = [Rubygame::Surface.load("visuals/text/letters/lx.png"), 10]
	LY = [Rubygame::Surface.load("visuals/text/letters/ly.png"), 10]
	LZ = [Rubygame::Surface.load("visuals/text/letters/lz.png"), 10]

	ONE = [Rubygame::Surface.load("visuals/text/letters/one.png"), 4]
	TWO = [Rubygame::Surface.load("visuals/text/letters/two.png"), 10]
	THREE = [Rubygame::Surface.load("visuals/text/letters/three.png"), 10]
	FOUR = [Rubygame::Surface.load("visuals/text/letters/four.png"), 10]
	FIVE = [Rubygame::Surface.load("visuals/text/letters/five.png"), 10]
	SIX = [Rubygame::Surface.load("visuals/text/letters/six.png"), 10]
	SEVEN = [Rubygame::Surface.load("visuals/text/letters/seven.png"), 10]
	EIGHT = [Rubygame::Surface.load("visuals/text/letters/eight.png"), 10]
	NINE = [Rubygame::Surface.load("visuals/text/letters/nine.png"), 10]
	ZERO = [Rubygame::Surface.load("visuals/text/letters/zero.png"), 10]

	PERIOD = [Rubygame::Surface.load("visuals/text/letters/period.png"), 4]
	COMMA = [Rubygame::Surface.load("visuals/text/letters/comma.png"), 4]
	APO = [Rubygame::Surface.load("visuals/text/letters/apo.png"), 4]
	QMARK = [Rubygame::Surface.load("visuals/text/letters/qmark.png"), 4]
	EXPT = [Rubygame::Surface.load("visuals/text/letters/expt.png"), 4]

	BOX_TOP_RIGHT = Rubygame::Surface.load("visuals/text/textBox_topright.png")
	BOX_TOP_LEFT = Rubygame::Surface.load("visuals/text/textBox_topleft.png")
	BOX_BOTTOM_RIGHT = Rubygame::Surface.load("visuals/text/textBox_bottomright.png")
	BOX_BOTTOM_LEFT = Rubygame::Surface.load("visuals/text/textBox_bottomleft.png")
	BOX_LEFT = Rubygame::Surface.load("visuals/text/textBox_left.png")
	BOX_RIGHT = Rubygame::Surface.load("visuals/text/textBox_right.png")
	BOX_TOP = Rubygame::Surface.load("visuals/text/textBox_top.png")
	BOX_BOTTOM = Rubygame::Surface.load("visuals/text/textBox_bottom.png")
	BOX_MIDDLE = Rubygame::Surface.load("visuals/text/textBox_middle.png")

	SQUARE_SIZE = 12
	SPACE_SIZE = 6

	def initialize(initX, initY, sizeX, sizeY, textInitX, textInitY, spacingX, spacingY, list, screen)
		@screen = screen
		@initX = initX
		@initY = initY
		@sizeX = sizeX
		@sizeY = sizeY
		@textInitX = textInitX
		@textInitY = textInitY
		@spacingX = spacingX
		@spacingY = spacingY
		@list = list
	end

	def setList(list)
		@list = list
	end

	def draw
		drawBox
		posX = @initX + @textInitX
		posY = @initY + @textInitY
		@list.each { |words|
			wordCount = 0
			words.each { |word|
				word = transformWord(word)
				word.word.each { |c|
					c[0].blit(@screen, [posX, posY], nil)
					posX = posX + c[1]
				}
				wordCount = wordCount + 1
				posX = @initX + @textInitX + @spacingX * wordCount + SPACE_SIZE
			}
			posX = @initX + @textInitX
			posY = posY + @spacingY
		}
	end

private
	#Converts a string into drawable text, including line breaks.
	def transformWord(text)
		puts text
		word = Word.new
		text.each_char { |c|
			case c
			when "A"
				word.add(A)
			when "B"
				word.add(B)
			when "C"
				word.add(C)
			when "D"
				word.add(D)
			when "E"
				word.add(E)
			when "F"
				word.add(F)
			when "G"
				word.add(G)
			when "H"
				word.add(H)
			when "I"
				word.add(I)
			when "J"
				word.add(J)
			when "K"
				word.add(K)
			when "L"
				word.add(L)
			when "M"
				word.add(M)
			when "N"
				word.add(N)
			when "O"
				word.add(O)
			when "P"
				word.add(P)
			when "Q"
				word.add(Q)
			when "R"
				word.add(R)
			when "S"
				word.add(S)
			when "T"
				word.add(T)
			when "U"
				word.add(U)
			when "V"
				word.add(V)
			when "W"
				word.add(W)
			when "X"
				word.add(X)
			when "Y"
				word.add(Y)
			when "Z"
				word.add(Z)

			when "a"
				word.add(LA)
			when "b"
				word.add(LB)
			when "c"
				word.add(LC)
			when "d"
				word.add(LD)
			when "e"
				word.add(LE)
			when "f"
				word.add(LF)
			when "g"
				word.add(LG)
			when "h"
				word.add(LH)
			when "i"
				word.add(LI)
			when "j"
				word.add(LJ)
			when "k"
				word.add(LK)
			when "l"
				word.add(LL)
			when "m"
				word.add(LM)
			when "n"
				word.add(LN)
			when "o"
				word.add(LO)
			when "p"
				word.add(LP)
			when "q"
				word.add(LQ)
			when "r"
				word.add(LR)
			when "s"
				word.add(LS)
			when "t"
				word.add(LT)
			when "u"
				word.add(LU)
			when "v"
				word.add(LV)
			when "w"
				word.add(LW)
			when "x"
				word.add(LX)
			when "y"
				word.add(LY)
			when "z"
				word.add(LZ)

			when "1"
				word.add(ONE)
			when "2"
				word.add(TWO)
			when "3"
				word.add(THREE)
			when "4"
				word.add(FOUR)
			when "5"
				word.add(FIVE)
			when "6"
				word.add(SIX)
			when "7"
				word.add(SEVEN)
			when "8"
				word.add(EIGHT)
			when "9"
				word.add(NINE)
			when "0"
				word.add(ZERO)

			when "."
				word.add(PERIOD)
			when ","
				word.add(COMMA)
			when "'"
				word.add(APO)
			when "!"
				word.add(EXPT)
			when "?"
				word.add(QMARK)
			end
		}
		return word
	end

	def drawBox
		BOX_TOP_LEFT.blit(@screen, [@initX, @initY], nil)
		(1...@sizeX).each { |x|
			BOX_TOP.blit(@screen, [@initX + x * SQUARE_SIZE, @initY], nil)
		}
		BOX_TOP_RIGHT.blit(@screen, [@initX + @sizeX * SQUARE_SIZE, @initY], nil)
		(1...@sizeY).each { |y|
			BOX_LEFT.blit(@screen, [@initX, @initY + y * SQUARE_SIZE], nil)
			(1...@sizeX).each { |x|
				BOX_MIDDLE.blit(@screen, [@initX + x * SQUARE_SIZE, @initY + y * SQUARE_SIZE], nil)
			}
			BOX_RIGHT.blit(@screen, [@initX + @sizeX * SQUARE_SIZE, @initY + y * SQUARE_SIZE], nil)
		}
		BOX_BOTTOM_LEFT.blit(@screen, [@initX, @initY + @sizeY * SQUARE_SIZE], nil)
		(1...@sizeX).each { |x|
			BOX_BOTTOM.blit(@screen, [@initX + x * SQUARE_SIZE, @initY + @sizeY * SQUARE_SIZE], nil)
		}
		BOX_BOTTOM_RIGHT.blit(@screen, [@initX + @sizeX * SQUARE_SIZE, @initY + @sizeY * SQUARE_SIZE], nil)
	end
end

#Stores a list of characters to form a word. Also keeps track of size.
class Word
	attr_reader :size
	attr_reader :word

	def initialize
		@word = []
		@size = 0
	end

	def add(letter)
		@word.push(letter)
		@size = @size + letter[1]
	end
end

#Stores a line of words. Keeps track of length, and can return the amount of space left in the line.
class Line
	SPACE_SIZE = 6

	attr_reader :line

	#Creates a line with the given size as max length.
	def initialize(maxSize)
		@line = []
		@size = 0
		@maxSize = maxSize
	end

	def add(word)
		@line.push(word)
		@size = @size + word.size + SPACE_SIZE
	end

	def remainingSpace
		return @maxSize - @size
	end
end

class DescriptionBox < TextBox
	BOX = Rubygame::Surface.load("visuals/text/dialogue.png")
	SPACE_SIZE = 6
	DRAW_POS_X = 90
	LINE_SIZE = 456
	LINE_HEIGHT = 20

	#Sets the screen and text to be displayed. Call update to draw on screen.
	def initialize(text, screen)
		@text = text
		@lines = parseText(text.delete_at(0))
		@screen = screen
		@textbox = BOX
	end

	def setText(text)
		@text = text
		@lines = parseText(text.delete_at(0))
	end

	def appendText(text)
		@text.push(text)
	end

	def next
		@next = false
		if !@text.empty?
			setText(@text)
			#@lines = parseText(@text.delete_at(0))
			@next = true
		end
		return @next
	end

	#Draws the textbox and text onto the screen.
	def draw
		@textbox.blit(@screen, [60, 280], nil)
		drawLines
	end
	
private
	def parseText(text)
		text = text.split(" ")
		line = Line.new(LINE_SIZE)
		lines = []
		text.each { |word|
			word = transformWord(word)
			if line.remainingSpace >= word.size
				line.add(word)
			else
				lines.push(line)
				line = Line.new(LINE_SIZE)
				line.add(word)
			end
		}
		lines.push(line)
		return lines
	end

	#Draws each line of letters.
	def drawLines
		#Set inital text height and change per line.
		if @lines.length == 4
			drawPosY = 292
		elsif @lines.length == 3
			drawPosY = 300
		elsif @lines.length == 2
			drawPosY = 310
		else
			drawPosY = 322
		end
		drawPosX = DRAW_POS_X

		@lines.each { |line|
			line.line.each { |word|
				word.word.each { |c|
					c[0].blit(@screen, [drawPosX, drawPosY], nil)
					drawPosX = drawPosX + c[1]
				}
				drawPosX = drawPosX + SPACE_SIZE
			}
		drawPosX = DRAW_POS_X
		drawPosY = drawPosY + LINE_HEIGHT
		}
	end
end

class DialogueBox < DescriptionBox
	DRAW_POS_X = 90
	SPACE_SIZE = 6

	def initialize(text, screen)
		super(text, screen)
		setUp
	end

	def setText(text)
		super(text)
		setUp
	end

	def draw
		#lineCount = 0
		#while !@lines(lineCount).empty?
		#	lineCount = lineCount + 1
		#end
		if @lines.length > 0
			if !@writing
				@textbox.blit(@screen, [60, 280], nil)
				@writing = true
			else
				drawPosY = @drawPosY + @lineCount * 20
				puts @lineCount
				puts @lines.length
				line = @lines[0]
				word = line.line[0]
				repeat = drawChar(word, line, drawPosY)
				if repeat
					drawChar(word, line, drawPosY)
				end	
				@writing = @lines.length > 0 
			end
		end
	end

private
	def drawChar(word, line, drawPosY)
		@repeat = true
		c = word.word.delete_at(0)
		if word.word.length == 0
			line.line.delete_at(0)
			@repeat = false
		end
		c[0].blit(@screen, [@drawPosX, drawPosY], nil) 
		if line.line.length == 0
			@drawPosX = DRAW_POS_X
			@lines.delete_at(0)
			@lineCount = @lineCount + 1
		else
			@drawPosX = @drawPosX + c[1] 
			if word.word.length == 0
				@drawPosX = @drawPosX + SPACE_SIZE
			end
		end
		return @repeat
	end

	def setUp
		if @lines.length == 4
			@drawPosY = 292
		elsif @lines.length == 3
			@drawPosY = 300
		elsif @lines.length == 2
			@drawPosY = 310
		else
			@drawPosY = 322
		end
		@drawPosX = DRAW_POS_X
		@lineCount = 0
		@writing = false
	end
end

class OptionBox < TextBox
	OPTION = Rubygame::Surface.load("visuals/text/option.png")
	SPACE_SIZE = 6

	def initialize(initX, initY, sizeX, sizeY, textInitX, textInitY, spacingX, spacingY, list, screen)
		super(initX, initY, sizeX, sizeY, textInitX, textInitY, spacingX, spacingY, list, screen)
		@options = list
		@currentOption = [0, 0]
		@lengthX = @options[0].length
		@lengthY = @options.length
	end

	def changeOption(changeX, changeY)
		if @currentOption[0] + changeX < @lengthX and @currentOption[0] + changeX >= 0 and @currentOption[1] + changeY < @lengthY and @currentOption[1] + changeY >= 0
			@currentOption[0] = @currentOption[0] + changeX
			@currentOption[1] = @currentOption[1] + changeY
			draw
			return true
		else
			return false
		end
	end

	def changeOptionStrict(changeX, changeY) 
		if @currentOption[0] + changeX < @lengthX and @currentOption[0] + changeX >= 0 and @currentOption[1] + changeY < @lengthY and @currentOption[1] + changeY >= 0
			if @options[@currentOption[0] + changeX][@currentOption[1] + changeY] != "" 
				@currentOption[0] = @currentOption[0] + changeX
				@currentOption[1] = @currentOption[1] + changeY
				draw
				return true
			end
		else
			return false
		end
	end


	def getOption
		return @options[@currentOption[1]][@currentOption[0]]
	end

	def getOptionIndex
		return @currentOption
	end

	def reset
		@currentOption = [0, 0]
		draw
	end
	
	def draw
		drawBox
		textInitX = @initX + @textInitX
		textInitY = @initY + @textInitY
		currentY = textInitY
		currentX = textInitX

		(0...@lengthY).each { |y|
			currentY = textInitY + @spacingY * y
			(0...@lengthX).each { |x|
				currentX = textInitX + @spacingX * x
				option = @options[y][x]
				if option.class == String
					words = option.split(" ")
					word = transformWord(option)
				else
					words = option.getName.split(" ")
					word = transformWord(option.getName)
				end
				drawWords = []
				words.each { |word|
					drawWords.push(transformWord(word))
				}
				if (x == @currentOption[0] and y == @currentOption[1])
					OPTION.blit(@screen, [currentX, currentY], nil)
				end
				currentX = currentX + 8
				drawWords.each { |word|
					word.word.each { |c|
						c[0].blit(@screen, [currentX, currentY], nil)
						currentX = currentX + c[1]
					}
					currentX = currentX + SPACE_SIZE
				}
			}
			currentX = @textInitX
		}
	end
end


