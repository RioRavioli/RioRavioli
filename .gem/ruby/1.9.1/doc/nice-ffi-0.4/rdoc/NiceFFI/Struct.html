<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: NiceFFI::Struct</title>

  <link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../lib/nice-ffi/struct_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/nice-ffi/struct.rb">lib/nice-ffi/struct.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">FFI::Struct</p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-hidden">::hidden</a></li>
          
          <li><a href="#method-c-hidden-3F">::hidden?</a></li>
          
          <li><a href="#method-c-layout">::layout</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-read_only">::read_only</a></li>
          
          <li><a href="#method-c-read_only-3F">::read_only?</a></li>
          
          <li><a href="#method-c-typed_pointer">::typed_pointer</a></li>
          
          <li><a href="#method-i-inspect">#inspect</a></li>
          
          <li><a href="#method-i-to_ary">#to_ary</a></li>
          
          <li><a href="#method-i-to_bytes">#to_bytes</a></li>
          
          <li><a href="#method-i-to_hash">#to_hash</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><a class="include" href="AutoRelease.html">NiceFFI::AutoRelease</a></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../NiceFFI.html">NiceFFI</a></li>
        
          <li><a href="../NiceFFI/AutoRelease.html">NiceFFI::AutoRelease</a></li>
        
          <li><a href="../NiceFFI/Library.html">NiceFFI::Library</a></li>
        
          <li><a href="../NiceFFI/OpaqueStruct.html">NiceFFI::OpaqueStruct</a></li>
        
          <li><a href="../NiceFFI/PathSet.html">NiceFFI::PathSet</a></li>
        
          <li><a href="../NiceFFI/Struct.html">NiceFFI::Struct</a></li>
        
          <li><a href="../NiceFFI/TypedPointer.html">NiceFFI::TypedPointer</a></li>
        
          <li><a href="../Object.html">Object</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">NiceFFI::Struct</h1>

    <div id="description" class="description">
      
<p>A class to be used as a baseclass where you would use FFI::Struct. It acts
mostly like FFI::Struct, but with nice extra features and conveniences to
make life easier:</p>
<ul><li>
<p>Automatically defines read and write accessor methods (e.g. x, x=) for
struct members when you call layout. (You can use hidden and read_only
before or after calling layout to affect which members have accessors.)</p>
</li><li>
<p>Implements “smart” accessors for <a
href="TypedPointer.html">TypedPointer</a> types, seamlessly wrapping those
members so you don’t even have to think about the fact they are pointers!</p>
</li><li>
<p>Implements a nicer new method which allows you to create a new struct and
set its data in one shot by passing an Array, Hash, or another instance of
the class (to copy data). You can also use it to wrap a FFI::Pointer like
FFI::Struct can.</p>
</li><li>
<p>Implements <a href="Struct.html#method-i-to_ary">to_ary</a> and <a
href="Struct.html#method-i-to_hash">to_hash</a> to dump the struct data.</p>
</li><li>
<p>Implements <a href="Struct.html#method-i-to_s">to_s</a> and <a
href="Struct.html#method-i-inspect">inspect</a> for nice debugging output.</p>
</li><li>
<p>Adds <a href="Struct.html#method-c-typed_pointer">::typed_pointer</a>
convenience alias to create a <a href="TypedPointer.html">TypedPointer</a>
for this klass.</p>
</li><li>
<p>Provides automatic memory management for Pointers if you define
MyClass.release( pointer). (This can be disabled per-instance by providing
{:autorelease =&gt; false} as an option to new).</p>
</li></ul>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="hidden-method" class="method-detail ">
          <a name="method-c-hidden"></a>

          
          <div class="method-heading">
            <span class="method-name">hidden</span><span
              class="method-args">( *members )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Mark the given members as hidden, i.e. do not create accessors for them in
layout, and do not print them out in <a
href="Struct.html#method-i-to_s">to_s</a>, etc. You can call this before or
after calling layout, and can call it more than once if you like.</p>

<p>Note: They can still be read and written via #[] and #[]=, but will not
have convenience accessors.</p>

<p>Note: This will remove the accessor methods (if they exist) for the
members! So if you’re defining your own custom accessors, do that
<b>after</b> you have called this method.</p>

<p>Example:</p>

<pre>class SecretStruct &lt; NiceStruct

  # You can use it before the layout...
  hidden( :hidden1 )

  layout( :visible1, :uint16,
          :visible2, :int,
          :hidden1,  :uint,
          :hidden2,  :pointer )

  # ... and/or after it.
  hidden( :hidden2 )

  # :hidden1 and :hidden2 are now both hidden.
end</pre>
            

            
            <div class="method-source-code" id="hidden-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 138</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hidden</span>( *<span class="ruby-identifier">members</span> )
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@hidden_members</span>)
    <span class="ruby-ivar">@hidden_members</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">members</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@hidden_members</span> = <span class="ruby-identifier">members</span> 
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">members</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">member</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># Remove the accessors if they exist.</span>
    [<span class="ruby-identifier">member</span>, <span class="ruby-node">&quot;#{member}=&quot;</span>.<span class="ruby-identifier">to_sym</span>].<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
      <span class="ruby-keyword">begin</span>
        <span class="ruby-identifier">remove_method</span>( <span class="ruby-identifier">m</span> )
      <span class="ruby-keyword">rescue</span> <span class="ruby-constant">NameError</span>
      <span class="ruby-keyword">end</span>
    }
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- hidden-source -->
            
          </div>

          

          
        </div><!-- hidden-method -->

      
        <div id="hidden-3F-method" class="method-detail ">
          <a name="method-c-hidden-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">hidden?</span><span
              class="method-args">( member )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>True if the member has been marked hidden, false otherwise.</p>
            

            
            <div class="method-source-code" id="hidden-3F-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 158</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">hidden?</span>( <span class="ruby-identifier">member</span> )
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@hidden_members</span>)
  <span class="ruby-ivar">@hidden_members</span>.<span class="ruby-identifier">include?</span>( <span class="ruby-identifier">member</span> )
<span class="ruby-keyword">end</span></pre>
            </div><!-- hidden-3F-source -->
            
          </div>

          

          
        </div><!-- hidden-3F-method -->

      
        <div id="layout-method" class="method-detail ">
          <a name="method-c-layout"></a>

          
          <div class="method-heading">
            <span class="method-name">layout</span><span
              class="method-args">( *spec )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Same syntax as FFI::Struct#layout, but also defines nice accessors for the
attributes.</p>

<p>Example:</p>

<pre>class Rect &lt; NiceStruct
  layout( :x, :int16,
          :y, :int16,
          :w, :uint16,
          :h, :uint16 )
end</pre>
            

            
            <div class="method-source-code" id="layout-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 85</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">layout</span>( *<span class="ruby-identifier">spec</span> )
  <span class="ruby-ivar">@nice_spec</span> = <span class="ruby-identifier">spec</span>

  <span class="ruby-comment"># Wrap the members.</span>
  <span class="ruby-value">0</span>.<span class="ruby-identifier">step</span>(<span class="ruby-identifier">spec</span>.<span class="ruby-identifier">size</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>, <span class="ruby-value">2</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">index</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">member</span>, <span class="ruby-identifier">type</span> = <span class="ruby-identifier">spec</span>[<span class="ruby-identifier">index</span>, <span class="ruby-value">2</span>]
    <span class="ruby-identifier">wrap_member</span>( <span class="ruby-identifier">member</span>, <span class="ruby-identifier">type</span>)
  }

  <span class="ruby-identifier">simple_spec</span> = <span class="ruby-identifier">spec</span>.<span class="ruby-identifier">collect</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">a</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">case</span> <span class="ruby-identifier">a</span>
    <span class="ruby-keyword">when</span> <span class="ruby-constant">NiceFFI</span><span class="ruby-operator">::</span><span class="ruby-constant">TypedPointer</span>
      <span class="ruby-value">:pointer</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">a</span>
    <span class="ruby-keyword">end</span>
  }

  <span class="ruby-comment"># Normal FFI::Struct behavior</span>
  <span class="ruby-keyword">super</span>( *<span class="ruby-identifier">simple_spec</span> )
<span class="ruby-keyword">end</span></pre>
            </div><!-- layout-source -->
            
          </div>

          

          
        </div><!-- layout-method -->

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">( val, options={} )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Create a new instance of the class, reading data from a Hash or Array of
attributes, a bytestring of raw data, copying from another instance of the
class, or wrapping (not copying!) a FFI::Pointer.</p>

<p>If val is an instance of FFI::Pointer and you have defined MyClass.release,
the pointer will be passed to MyClass.release when the memory is no longer
being used. Use MyClass.release to free the memory for the struct, as
appropriate for your class. To disable autorelease for this instance, set
{:autorelease =&gt; false} in <tt>options</tt>.</p>

<p>(Note: FFI::MemoryPointer and FFI::Buffer have built-in memory management,
so MyClass.release is never called for them.)</p>
            

            
            <div class="method-source-code" id="new-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 331</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>( <span class="ruby-identifier">val</span>, <span class="ruby-identifier">options</span>={} )
  <span class="ruby-comment"># Stores certain kinds of member values so that we don't need</span>
  <span class="ruby-comment"># to create a new object every time they are read.</span>
  <span class="ruby-ivar">@member_cache</span> = {}

  <span class="ruby-identifier">options</span> = {<span class="ruby-value">:autorelease</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span>}.<span class="ruby-identifier">merge!</span>( <span class="ruby-identifier">options</span> )

  <span class="ruby-keyword">case</span> <span class="ruby-identifier">val</span>

  <span class="ruby-keyword">when</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-keyword">super</span>(<span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">size</span>))
    <span class="ruby-identifier">init_from_hash</span>( <span class="ruby-identifier">val</span> )         <span class="ruby-comment"># Read the values from a Hash.</span>

  <span class="ruby-comment"># Note: plain &quot;Array&quot; would mean FFI::Struct::Array in this scope.</span>
  <span class="ruby-keyword">when</span> <span class="ruby-operator">::</span><span class="ruby-constant">Array</span>
    <span class="ruby-keyword">super</span>(<span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">size</span>))
    <span class="ruby-identifier">init_from_array</span>( <span class="ruby-identifier">val</span> )        <span class="ruby-comment"># Read the values from an Array.</span>

  <span class="ruby-keyword">when</span> <span class="ruby-constant">String</span>
    <span class="ruby-keyword">super</span>(<span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">size</span>))
    <span class="ruby-identifier">init_from_bytes</span>( <span class="ruby-identifier">val</span> )        <span class="ruby-comment"># Read the values from a bytestring.</span>

  <span class="ruby-keyword">when</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>
    <span class="ruby-keyword">super</span>(<span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">size</span>))
    <span class="ruby-identifier">init_from_bytes</span>( <span class="ruby-identifier">val</span>.<span class="ruby-identifier">to_bytes</span> ) <span class="ruby-comment"># Read the values from another instance.</span>

  <span class="ruby-keyword">when</span> <span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Pointer</span>, <span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Buffer</span>
    <span class="ruby-identifier">val</span> = <span class="ruby-identifier">_make_autopointer</span>( <span class="ruby-identifier">val</span>, <span class="ruby-identifier">options</span>[<span class="ruby-value">:autorelease</span>] )

    <span class="ruby-comment"># Normal FFI::Struct behavior to wrap the pointer.</span>
    <span class="ruby-keyword">super</span>( <span class="ruby-identifier">val</span> )

  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">TypeError</span>, <span class="ruby-node">&quot;cannot create new #{self.class} from #{val.inspect}&quot;</span>

  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
        <div id="read_only-method" class="method-detail ">
          <a name="method-c-read_only"></a>

          
          <div class="method-heading">
            <span class="method-name">read_only</span><span
              class="method-args">( *members )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Mark the given members as read-only, so they won’t have write accessors.</p>

<p>Note: They can still be written via #[]=, but will not have convenience
accessors.</p>

<p>Note: This will remove the writer method (if it exists) for the members! So
if you’re defining your own custom writer, do that <b>after</b> you have
called this method.</p>

<p>Example:</p>

<pre>class SecretStruct &lt; NiceStruct

  # You can use it before the layout...
  read_only( :readonly1 )

  layout( :visible1,  :uint16,
          :visible2,  :int,
          :readonly1, :uint,
          :readonly2, :pointer )

  # ... and/or after it.
  read_only( :readonly2 )

  # :readonly1 and :readonly2 are now both read-only.
end</pre>
            

            
            <div class="method-source-code" id="read_only-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 192</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read_only</span>( *<span class="ruby-identifier">members</span> )
  <span class="ruby-keyword">if</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@readonly_members</span>)
    <span class="ruby-ivar">@readonly_members</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">members</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-ivar">@readonly_members</span> = <span class="ruby-identifier">members</span> 
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">members</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">member</span><span class="ruby-operator">|</span>
    <span class="ruby-comment"># Remove the write accessor if it exists.</span>
    <span class="ruby-keyword">begin</span>
      <span class="ruby-identifier">remove_method</span>( <span class="ruby-node">&quot;#{member}=&quot;</span>.<span class="ruby-identifier">to_sym</span> )
    <span class="ruby-keyword">rescue</span> <span class="ruby-constant">NameError</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- read_only-source -->
            
          </div>

          

          
        </div><!-- read_only-method -->

      
        <div id="read_only-3F-method" class="method-detail ">
          <a name="method-c-read_only-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">read_only?</span><span
              class="method-args">( member )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>True if the member has been marked read_only, false otherwise.</p>
            

            
            <div class="method-source-code" id="read_only-3F-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 209</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">read_only?</span>( <span class="ruby-identifier">member</span> )
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span> <span class="ruby-keyword">unless</span> <span class="ruby-keyword">defined?</span>(<span class="ruby-ivar">@readonly_members</span>)
  <span class="ruby-ivar">@readonly_members</span>.<span class="ruby-identifier">include?</span>( <span class="ruby-identifier">member</span> )
<span class="ruby-keyword">end</span></pre>
            </div><!-- read_only-3F-source -->
            
          </div>

          

          
        </div><!-- read_only-3F-method -->

      
        <div id="typed_pointer-method" class="method-detail ">
          <a name="method-c-typed_pointer"></a>

          
          <div class="method-heading">
            <span class="method-name">typed_pointer</span><span
              class="method-args">( options={} )</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Returns a <a href="TypedPointer.html">NiceFFI::TypedPointer</a> instance
for this class. Equivalent to <a
href="TypedPointer.html#method-c-new">NiceFFI::TypedPointer.new</a>(
this_class, options )</p>
            

            
            <div class="method-source-code" id="typed_pointer-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 68</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">typed_pointer</span>( <span class="ruby-identifier">options</span>={} )
  <span class="ruby-constant">NiceFFI</span><span class="ruby-operator">::</span><span class="ruby-constant">TypedPointer</span>.<span class="ruby-identifier">new</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">options</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- typed_pointer-source -->
            
          </div>

          

          
        </div><!-- typed_pointer-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="inspect-method" class="method-detail method-alias">
          <a name="method-i-inspect"></a>

          
          <div class="method-heading">
            <span class="method-name">inspect</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
          </div>

          

          
          <div class="aliases">
            Alias for: <a href="Struct.html#method-i-to_s">to_s</a>
          </div>
          
        </div><!-- inspect-method -->

      
        <div id="to_ary-method" class="method-detail ">
          <a name="method-i-to_ary"></a>

          
          <div class="method-heading">
            <span class="method-name">to_ary</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Dump this instance as an Array of its struct data. The array contains only
the data, not the member names.</p>

<p>Note: the order of data in the array always matches the order of members
given in layout.</p>

<p>Example:</p>

<pre>Rect.new( :x=&gt;1, :y=&gt;2, :w=&gt;3, :h=&gt;4 ).to_ary
# =&gt; [1,2,3,4]</pre>
            

            
            <div class="method-source-code" id="to_ary-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 404</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_ary</span>
  <span class="ruby-identifier">members</span>.<span class="ruby-identifier">collect</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> <span class="ruby-keyword">self</span>[<span class="ruby-identifier">m</span>] }
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_ary-source -->
            
          </div>

          

          
        </div><!-- to_ary-method -->

      
        <div id="to_bytes-method" class="method-detail ">
          <a name="method-i-to_bytes"></a>

          
          <div class="method-heading">
            <span class="method-name">to_bytes</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Dump this instance as a string of raw bytes of its struct data.</p>
            

            
            <div class="method-source-code" id="to_bytes-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 411</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_bytes</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">pointer</span>.<span class="ruby-identifier">get_bytes</span>(<span class="ruby-value">0</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_bytes-source -->
            
          </div>

          

          
        </div><!-- to_bytes-method -->

      
        <div id="to_hash-method" class="method-detail ">
          <a name="method-i-to_hash"></a>

          
          <div class="method-heading">
            <span class="method-name">to_hash</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Dump this instance as a Hash containing {member =&gt; data} pairs for every
member in the struct.</p>

<p>Example:</p>

<pre>Rect.new( :x=&gt;1, :y=&gt;2, :w=&gt;3, :h=&gt;4 ).to_hash
# =&gt; {:h=&gt;4, :w=&gt;3, :x=&gt;1, :y=&gt;2}</pre>
            

            
            <div class="method-source-code" id="to_hash-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 424</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_hash</span>
  <span class="ruby-keyword">return</span> {} <span class="ruby-keyword">if</span> <span class="ruby-identifier">members</span>.<span class="ruby-identifier">empty?</span>
  <span class="ruby-constant">Hash</span>[ *(<span class="ruby-identifier">members</span>.<span class="ruby-identifier">collect</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span> [<span class="ruby-identifier">m</span>, <span class="ruby-keyword">self</span>[<span class="ruby-identifier">m</span>]] }.<span class="ruby-identifier">flatten!</span>) ]
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_hash-source -->
            
          </div>

          

          
        </div><!-- to_hash-method -->

      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          <div class="method-heading">
            <span class="method-name">to_s</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="to_s-source">
<pre>
<span class="ruby-comment"># File lib/nice-ffi/struct.rb, line 430</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">to_s</span>
  <span class="ruby-keyword">begin</span>
    <span class="ruby-keyword">if</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">pointer</span>.<span class="ruby-identifier">null?</span>
      <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;#&lt;NULL %s:%#.x&gt;&quot;</span><span class="ruby-operator">%</span>[<span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">object_id</span>]
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">rescue</span> <span class="ruby-constant">NoMethodError</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">mems</span> = <span class="ruby-identifier">members</span>.<span class="ruby-identifier">collect</span>{ <span class="ruby-operator">|</span><span class="ruby-identifier">m</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">unless</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">hidden?</span>( <span class="ruby-identifier">m</span> )
      <span class="ruby-identifier">val</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">m</span>)

      <span class="ruby-comment"># Cleanup/simplify for display</span>
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">nil?</span> <span class="ruby-keyword">or</span> (<span class="ruby-identifier">val</span>.<span class="ruby-identifier">is_a?</span> <span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Pointer</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">null?</span>)
        <span class="ruby-identifier">val</span> = <span class="ruby-string">&quot;NULL&quot;</span> 
      <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">FFI</span><span class="ruby-operator">::</span><span class="ruby-constant">Struct</span>
        <span class="ruby-identifier">val</span> = <span class="ruby-node">&quot;#&lt;#{val.class}:%#.x&gt;&quot;</span><span class="ruby-operator">%</span><span class="ruby-identifier">val</span>.<span class="ruby-identifier">object_id</span>
      <span class="ruby-keyword">end</span>
      
      <span class="ruby-node">&quot;@#{m}=#{val}&quot;</span>
    <span class="ruby-keyword">end</span>
  }.<span class="ruby-identifier">compact</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;, &quot;</span>)

  <span class="ruby-keyword">if</span>( <span class="ruby-identifier">mems</span> <span class="ruby-operator">==</span> <span class="ruby-string">&quot;&quot;</span> )
    <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;#&lt;%s:%#.x&gt;&quot;</span><span class="ruby-operator">%</span>[<span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">object_id</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-node">&quot;#&lt;%s:%#.x %s&gt;&quot;</span><span class="ruby-operator">%</span>[<span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">object_id</span>, <span class="ruby-identifier">mems</span>]
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- to_s-source -->
            
          </div>

          
          <div class="aliases">
            Also aliased as: <a href="Struct.html#method-i-inspect">inspect</a>
          </div>
          

          
        </div><!-- to_s-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

